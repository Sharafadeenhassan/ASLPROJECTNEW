OBJECT Table 50006 Payroll-Payslip Lines.
{
  OBJECT-PROPERTIES
  {
    Date=15/06/16;
    Time=11:52:05;
    Modified=Yes;
    Version List=CBU Ver. 1.00,LOAN1.0;
  }
  PROPERTIES
  {
    OnModify=BEGIN
               {���������������������������������������������������������������������������Ŀ
               � This trigger is called if any of the fields in "KI03b P.Roll Entry" is     �
               � not equal to the corresponding field in "xKI03b P.Roll Entry"              �
               �����������������������������������������������������������������������������}

               IF (Rec.Amount <> xRec.Amount) OR ("Loan ID"<>'') OR (Rec."Payslip Column"<>0) THEN
               BEGIN
                  MARK( TRUE);
                 { If this new entry contributes in computing another, then compute that value
                   for that computed entry and insert it appropriately}
                 CalcCompute (Rec, Rec.Amount, FALSE, "E/D Code");
               {BDC}

                 { If this new entry is a contributory factor for the value of another line,
                   then compute that other line's value and insert it appropriately }
                 CalcFactor1 (Rec);

                 { The two functions above have used this line to change others }
                 ChangeOthers := FALSE;

                 { Go through all the lines and change where necessary }
                 ChangeAllOver (Rec, FALSE);

                 { Reset the ChangeOthers flag in all lines }
               {    ResetChangeFlags (Rec);}

               {BDC
                  MARK( FALSE);}

               END;
             END;

    OnDelete=BEGIN
               //ProllHeader.GET( "Payroll Period", "Employee No");

               IF ProllHeader."Closed?" THEN
                 ERROR ('Entries for Employee %1/ in Period %2/ are closed. '+
                       'Nothing can be deleted', "Employee No", "Payroll Period");

               {Go through all the lines and make any appropriate Changes }
               ChangeOthers := FALSE;
               ChangeDueToDelete(Rec);

               { Set the 'Change' flags to false in all the lines }
               ResetChangeFlags(Rec);
             END;

    DrillDownPageID=Page50006;
  }
  FIELDS
  {
    { 1   ;   ;Payroll Period      ;Code10        ;TableRelation="Payroll-Periods.";
                                                   OnValidate=BEGIN
                                                                GetParam();
                                                              END;

                                                   Editable=No }
    { 2   ;   ;Employee No         ;Code20        ;TableRelation=Employee;
                                                   OnValidate=BEGIN
                                                                GetParam();
                                                              END;

                                                   NotBlank=Yes;
                                                   Editable=No }
    { 3   ;   ;E/D Code            ;Code20        ;TableRelation="Payroll-E/D Codes.";
      OnValidate=BEGIN
        GetParam();

        { If Period+Employee has already been closed then stop edit }
        IF CheckClosed  THEN
                                                                  ERROR ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                 "E/DFileRec".GET( "E/D Code");
        "Payslip Text" := "E/DFileRec"."Payslip Text";

        { Transfer Units, Rate, Payslip Group ID. and Pos in Payslip Group }
        BEGIN
                                                                  "Payslip Group ID" := "E/DFileRec"."Payslip Group ID";
                                                                  "Pos. In Payslip Grp." := "E/DFileRec"."Pos. In Payslip Grp.";
                                                                  "Payslip appearance" := "E/DFileRec"."Payslip appearance";
                                                                  "Payslip Print Column" := "E/DFileRec"."Payslip Print Column";
                                                                  "Payslip Text" := "E/DFileRec"."Payslip Text";
                                                                  Units := "E/DFileRec".Units;
                                                                  Rate := "E/DFileRec".Rate;
                                                                  "Overline Column" := "E/DFileRec"."Overline Column";
                                                                  "Underline Amount" := "E/DFileRec"."Underline Amount";
                                                                  "Variable Unit" := "E/DFileRec"."Variable Unit";
                                                                  "Monthly Variable" := "E/DFileRec"."Monthly Variable";
        END;

        { Calculate the amount if neither quantities nor yes flag are required}
        IF (Units = '') AND NOT ("E/DFileRec"."Yes/No Req.?") THEN
        BEGIN
             Amount := CalcAmount ("E/DFileRec", Rec, Amount, "E/D Code");
             IF Rec.Amount <> xRec.Amount THEN
             BEGIN
               { Change the entries that are computed using this new amount }
               CalcCompute (Rec, Amount, TRUE, "E/D Code");
        {BDC}
               { If this new entry contributes to the value of another line
                 then compute that other line's value and insert it appropriately}
               CalcFactor1 (Rec);

               { Go through all the lines and change where necessary }
               ChangeAllOver (Rec, FALSE);

               { Reset the ChangeOthers flag in all lines }
               ResetChangeFlags (Rec);
             END
        END;

        { Transfer from Booking Group Lines }
        EmployeeRec.GET("Employee No");
        IF  BookGrLinesRec.GET( EmployeeRec."Posting Group","E/D Code") THEN
        BEGIN
                                                                  BEGIN
                                                                    "Debit Account" := BookGrLinesRec."Debit Account No.";
                                                                    "Credit Account" := BookGrLinesRec."Credit Account No.";
                                                                    "Debit Acc. Type" := BookGrLinesRec."Debit Acc. Type";
                                                                    "Credit Acc. Type" := BookGrLinesRec."Credit Acc. Type";
        {BDC
                                                                    "Department Code" := BookGrLinesRec.Department;
                                                                    "Project Code" := BookGrLinesRec.Project;
        }
                                                                  END;
        {BDC
                                                                  IF NOT BookGrLinesRec."Transfer Department" THEN
                                                                    "Department Code" := ''
                                                                  ELSE
                                                                  IF "Department Code" = '' THEN
                                                                      "Department Code" := EmployeeRec.Department;

                                                                  IF NOT BookGrLinesRec."Transfer Project" THEN
                                                                    "Project Code" := ''
                                                                  ELSE
                                                                  IF "Project Code" = '' THEN
                                                                    "Project Code" := EmployeeRec.Project;

                                                                  IF BookGrLinesRec."Debit Acc. Type" = 1 THEN
                                                                    IF "Debit Account" = '' THEN
                                                                      IF EmployeeRec."Customer Number" <> '' THEN
                                                                        "Debit Account" := EmployeeRec."Customer Number" ;

                                                                  IF BookGrLinesRec."Credit Acc. Type" = 1 THEN
                                                                    IF "Credit Account" = '' THEN
                                                                      IF EmployeeRec."Customer Number"  <> '' THEN
                                                                        "Credit Account" := EmployeeRec."Customer Number" ;
         }

                                                                 IF BookGrLinesRec."Transfer Department" THEN
                                                                    "Global Dimension 1 Code" := EmployeeRec."Global Dimension 1 Code";
                                                                  IF BookGrLinesRec."Transfer Business Units" THEN
                                                                    "Global Dimension 2 Code" := EmployeeRec."Global Dimension 2 Code";
        END;
      END;

      NotBlank=Yes }
    { 4   ;   ;Units               ;Text10        ;Editable=No }
    { 5   ;   ;Rate                ;Decimal       ;OnValidate=BEGIN
                                                                GetParam();

                                                                { If Period+Employee has already been closed then stop edit }
                                                                IF CheckClosed  THEN
                                                                  ERROR ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                IF (Units = '') THEN
                                                                  { User cannot edit the rate if the E/D code has no units}
                                                                  Rec.Rate := xRec.Rate
                                                                ELSE
                                                                BEGIN
                                                                  Amount := Quantity * Rate;

                                                                  {Check for rounding, Maximum and minimum }
                                                                   "E/DFileRec".GET( "E/D Code");
                                                                  Amount := ChkRoundMaxMin ("E/DFileRec", Amount);

                                                                END
                                                              END;

                                                   DecimalPlaces=0:5 }
    { 6   ;   ;Quantity            ;Decimal       ;OnValidate=BEGIN
                                                                { If Period+Employee has already been closed then stop edit }
                                                                IF CheckClosed  THEN
                                                                  ERROR ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                IF (Units = '') THEN
                                                                  { User cannot enter quantity if the E/D code has no units}
                                                                  Rec.Quantity := xRec.Quantity
                                                                ELSE
                                                                BEGIN
                                                                  Amount := Quantity * Rate;

                                                                  {Check for rounding, Maximum and minimum }
                                                                   "E/DFileRec".GET( "E/D Code");
                                                                //  Amount := ChkRoundMaxMin ("E/DFileRec", Amount);
                                                                /////////////
                                                                GetParam();
                                                                IF ("Variable Unit" = "Variable Unit"::Hours) THEN
                                                                  Amount := ROUND((BasicPay * Rate  * Quantity)/(HrsInDay*DaysInMonth));

                                                                IF ("Variable Unit" = "Variable Unit"::Days) THEN
                                                                  Amount := ROUND((BasicPay * Rate  * Quantity)/DaysInMonth);

                                                                /////////////

                                                                END
                                                              END;

                                                   DecimalPlaces=0:5 }
    { 7   ;   ;Flag                ;Boolean       ;OnValidate=BEGIN
                                                                { If Period+Employee has already been closed then stop edit }
                                                                IF CheckClosed  THEN
                                                                  ERROR ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                 "E/DFileRec".GET("E/D Code");
                                                                IF NOT ("E/DFileRec"."Yes/No Req.?") THEN
                                                                  Flag := FALSE
                                                                ELSE
                                                                  Amount := CalcAmount ("E/DFileRec", Rec, Amount, "E/D Code");
                                                              END;
                                                               }
    { 8   ;   ;Amount              ;Decimal       ;OnValidate=BEGIN
                                                                { If Period+Employee has already been closed then stop edit }
                                                                IF CheckClosed  THEN
                                                                  ERROR ('Entries for Employee %1 for period %2 '+
                                                                         'have already been closed.', "Employee No", "Payroll Period");

                                                                IF "E/D Code"<>'' THEN  "E/DFileRec".GET( "E/D Code");
                                                                IF NOT ("E/DFileRec"."Edit Amount?") THEN
                                                                  Rec.Amount := xRec.Amount
                                                                ELSE
                                                                  {Check for rounding, Maximum and minimum }
                                                                  Amount := ChkRoundMaxMin ("E/DFileRec", Amount);
                                                              END;
                                                               }
    { 9   ;   ;Debit Account       ;Code20        ;TableRelation=IF (Debit Acc. Type=CONST(Finance)) "G/L Account"
                                                                 ELSE IF (Debit Acc. Type=CONST(Customer)) Customer;
                                                   OnValidate=BEGIN
                                                                IF "Debit Account" <> '' THEN
                                                                  CASE "Debit Acc. Type" OF
                                                                    0:  FinanceAccRec.GET( "Debit Account");
                                                                    1:  CustomerAccRec.GET( "Debit Account");
                                                                    2:  SupplierAccRec.GET( "Debit Account");
                                                                  END;
                                                              END;
                                                               }
    { 10  ;   ;Credit Account      ;Code20        ;TableRelation=IF (Credit Acc. Type=CONST(Finance)) "G/L Account"
                                                                 ELSE IF (Credit Acc. Type=CONST(Customer)) Customer;
                                                   OnValidate=BEGIN
                                                                IF "Credit Account" <> '' THEN
                                                                  CASE "Credit Acc. Type" OF
                                                                    0:  FinanceAccRec.GET(  "Credit Account");
                                                                    1:  CustomerAccRec.GET( "Credit Account");
                                                                    2:  SupplierAccRec.GET( "Credit Account");
                                                                  END;
                                                              END;
                                                               }
    { 11  ;   ;Global Dimension 1 Code;Code10     ;TableRelation="Dimension Value".Code WHERE (Global Dimension No.=CONST(1));
                                                   CaptionClass='1,1,1' }
    { 12  ;   ;Global Dimension 2 Code;Code10     ;TableRelation="Dimension Value".Code WHERE (Global Dimension No.=CONST(2));
                                                   CaptionClass='1,1,2' }
    { 13  ;   ;AmountToBook        ;Decimal       ;DecimalPlaces=0:5;
                                                   Editable=No }
    { 14  ;   ;Payslip Group ID    ;Option        ;OptionString=[ ,GROSS PAY,TAXABLE PAY,TAX CHARGED,TAX DEDUCTED,TOTAL DEDUCTIONS,NET PAY DUE] }
    { 15  ;   ;Pos. In Payslip Grp.;Integer        }
    { 16  ;   ;Payslip appearance  ;Option        ;OptionString=Non-zero & Code,Always & Code,Always & Text,Non-zero & Text,Does not appear,Heading }
    { 17  ;   ;Debit Acc. Type     ;Option        ;OptionString=Finance,Customer,Supplier }
    { 18  ;   ;Credit Acc. Type    ;Option        ;OptionString=Finance,Customer,Supplier }
    { 19  ;   ;ChangeOthers        ;Boolean       ;InitValue=No;
                                                   Editable=No }
    { 20  ;   ;HasBeenChanged      ;Boolean       ;InitValue=No;
                                                   Editable=No }
    { 21  ;   ;ChangeCounter       ;Integer       ;InitValue=0 }
    { 22  ;   ;Payslip Column      ;Option        ;InitValue=2;
                                                   OptionString=1,2,3 }
    { 23  ;   ;S. Report appearance;Option        ;OptionString=Non-zero & Code,Always & Code,Always & Text,Non-zero & Text,Does not appear,Heading }
    { 24  ;   ;Overline Column     ;Option        ;InitValue=None;
                                                   OptionString=None,1,2,3,1-2,2-3,1-3 }
    { 25  ;   ;Underline Amount    ;Option        ;InitValue=None;
                                                   OptionString=None,Underline,Double Underline }
    { 26  ;   ;Loan ID             ;Code10        ;TableRelation="Monthly Variables Header." }
    { 27  ;   ;Payslip Print Column;Option        ;OptionString=[ ,Postive,Negative,Total Earning,Total Deduction,Net Earning] }
    { 28  ;   ;Payslip Text        ;Text100        }
    { 29  ;   ;Variable Unit       ;Option        ;OnValidate=BEGIN
                                                                IF NOT "Monthly Variable" THEN "Variable Unit" := 0;
                                                              END;

                                                   OptionString=[ ,Hours,Days];
                                                   Editable=No }
    { 30  ;   ;Monthly Variable    ;Boolean       ;Description=Added for Overtime;
                                                   Editable=No }
    { 50000;  ;Postg Group         ;Code10        ;TableRelation="Payroll-Posting Group Header." }
  }
  KEYS
  {
    {    ;Payroll Period,Employee No,E/D Code     ;SumIndexFields=Amount;
                                                   Clustered=Yes }
    {    ;Payroll Period,Global Dimension 1 Code,Global Dimension 2 Code,Debit Acc. Type,Debit Account,Credit Acc. Type,Credit Account,Loan ID;
                                                   KeyGroups=MI-PROLL }
    {    ;Payroll Period,Employee No,Payslip Group ID,Pos. In Payslip Grp.;
                                                   KeyGroups=MI-PROLL }
    {    ;E/D Code,Employee No,Payroll Period     ;KeyGroups=MI-PROLL }
    {    ;Employee No,Payroll Period              ;KeyGroups=MI-PROLL }
    {    ;Payroll Period,Employee No,Global Dimension 1 Code,Global Dimension 2 Code }
    {    ;Global Dimension 2 Code,Global Dimension 1 Code }
    {    ;Payslip Print Column,E/D Code            }
    {    ;Debit Account,Credit Account            ;SumIndexFields=Amount }
  }
  FIELDGROUPS
  {
  }
  CODE
  {
    VAR
      "E/DFileRec"@1000000000 : Record 50001;
      ConstEDFileRec@1000000001 : Record 50001;
      EDRec2@1000000002 : Record 50001;
      ProllHeader@1000000003 : Record 50007;
      ProllRecStore@1000000004 : Record 50006;
      ProllFactorRec@1000000005 : Record 50006;
      ProllEntryRec@1000000006 : Record 50006;
      ChangeOthersRec@1000000007 : Record 50006;
      LookHeaderRec@1000000008 : Record 50002;
      LookLinesRec@1000000009 : Record 50003;
      BackOneRec@1000000010 : Integer;
      ReturnAmount@1000000011 : Decimal;
      PrevLookRec@1000000012 : Record 50003;
      InputAmount@1000000013 : Decimal;
      ComputedTotal@1000000014 : Decimal;
      AmountToAdd@1000000015 : Decimal;
      FactorRecAmount@1000000016 : Decimal;
      AmtToAdd@1000000017 : Decimal;
      EmployeeRec@1000000018 : Record 5200;
      BookGrLinesRec@1000000019 : Record 50010;
      RoundPrec@1000000020 : Decimal;
      RoundDir@1000000021 : Text[1];
      IsComputed@1000000022 : Boolean;
      FinanceAccRec@1000000023 : Record 15;
      CustomerAccRec@1000000024 : Record 18;
      SupplierAccRec@1000000025 : Record 23;
      MaxChangeCount@1000000026 : Integer;
      PayLines2@1000000027 : Record 50006;
      CurYear@1000000028 : Integer;
      PeriodRec@1000000029 : Record 50004;
      PerStart@1000000030 : Date;
      Per1@1000000031 : Code[10];
      YearStart@1000000032 : Date;
      T1@1000000033 : Decimal;
      T2@1000000034 : Decimal;
      PaySetup@1000000035 : Record 50000;
      HrsInDay@1000000036 : Integer;
      DaysInMonth@1000000037 : Integer;
      BasicPay@1000000038 : Decimal;
      TaxableED@1000000039 : Code[10];
      TaxfreeED@1000000040 : Code[10];
      TaxFreeYTD@1000000041 : Decimal;
      TaxableYTD@1000000042 : Decimal;
      TaxYTD@1000000043 : Decimal;
      AmountToTax@1000000044 : Decimal;
      TaxED@1000000045 : Code[10];
      NewTax@1000000046 : Decimal;
      MonthlyDays@1000000047 : Integer;
      VarRec@1000000048 : Record 50014;
      GenPCode@1000000049 : Codeunit 50001;
      CurrTaxable@1000000050 : Decimal;
      NewEmpRec@1000000051 : Record 5200;
      LookupRec@1000000052 : Record 50002;

    PROCEDURE SpecialRelation@100("FieldNo."@1000000000 : Integer);
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Special Relations code for the field, E/D Code                             �
      �����������������������������������������������������������������������������}

      { Force NO-EDIT of field already has a value or if Employee payroll details
        for the period are already closed}
      IF "E/D Code" <> '' THEN
        EXIT;

      { If Period+Employee has already been closed then stop edit }
      IF CheckClosed  THEN
        ERROR ('Entries for Employee %1 for period %2 '+
               'have already been closed.', "Employee No", "Payroll Period");
    END;

    PROCEDURE CalcAmount@1(EDFileRec@1000000000 : Record 50001;EntryLineRec@1000000001 : Record 50006;EntryLineAmount@1000000002 : Decimal;EDCode@1000000003 : Code[20]) : Decimal;
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Calculate the amount based on Factor Of and Percentage fields in the file  �
      � E/D file, alternatively calculate if the current line is computed by others�
      �  Parameters:                                                               �
      �    EDFileRec    : EDFile Record for the E/D Code of the current entry line �
      �    EntryLineRec : The current entry line record                            �
      �    EntryLineAmount: The amount in the current entry line. Note this        �
      �    parameter is important if this trigger is called from the SAVE trigger  �
      �����������������������������������������������������������������������������}

      { If NO is in the flag field return amount to 0}
      IF (EDFileRec."Yes/No Req.?") AND NOT (EntryLineRec.Flag) THEN
        EXIT (0);

      { If Factor Of is Nil then do not change then check if amount is computed by
        others}
      IF EDFileRec."Factor Of" = '' THEN
        IF NOT AmountIsComputed (ReturnAmount, EntryLineRec, EDFileRec,
                                 EntryLineAmount, EDCode) THEN
          {BDC}
          EXIT (EntryLineRec.Amount)
        ELSE
        BEGIN
          {Check for rounding, Maximum and minimum }
          ReturnAmount := ChkRoundMaxMin (EDFileRec, ReturnAmount);
          EXIT (ReturnAmount);
        END;
      { Get the record from the current file based on Factor Of }
      IF NOT  ProllFactorRec.GET( EntryLineRec."Payroll Period",
                       EntryLineRec."Employee No", EDFileRec."Factor Of") THEN
        EXIT (EntryLineRec.Amount)
      ELSE
        { If this 'Factor of' entry record is marked then this trigger was called
          from this 'Fator of' record, therefore ensure the amount to be used is
          the updated amount}
        {BDC
        IF  ProllFactorRec.MARK THEN
        }
        IF  ProllFactorRec."E/D Code" = EDCode THEN
          ProllFactorRec.Amount := EntryLineAmount;

      { Calculate the amount based on values in Table Look Up or Percentage fields
        of E/D file }
      IF EDFileRec."Table Look Up" = '' THEN
        ReturnAmount := (ProllFactorRec.Amount * EDFileRec.Percentage) / 100
      ELSE { Extract relevant amount from Table Look Up }

        IF NOT  LookHeaderRec.GET( EDFileRec."Table Look Up") THEN
        BEGIN
          MESSAGE ('Table Lookup Not Registered Yet');
          EXIT (EntryLineRec.Amount)
        END
        ELSE BEGIN { Table lookup exists}

          { Filter Lookupline records to those of current Table Id Only}
          LookLinesRec.TableId := EDFileRec."Table Look Up";
           LookLinesRec.SETRANGE(TableId, EDFileRec."Table Look Up");

          { Depending on whether input parameter is code or numeric, set dbSETRANGE
            appropraitely and initialise the record to use as a parameter to
            dbFINDREC }
      {    CASE LookHeaderRec.Type OF
          0:
            BEGIN
              { Lookup table is searched with numeric variables }
              IF ProllFactorRec.Amount > -1 THEN
                BEGIN
                  LookLinesRec."Lower Code" := '';
                  InputAmount := ProllFactorRec.Amount * LookHeaderRec."Input Factor";
                  LookLinesRec."Lower Amount" := InputAmount;
                  LookLinesRec.SETRANGE("Lower Code",'');
                END
              ELSE
                EXIT (LookHeaderRec."Min. Extract Amount")
            END;
          2:
            BEGIN
              { Lookup table is searched with numeric variables }
              IF ProllFactorRec.Amount > -1 THEN
                BEGIN
                  LookLinesRec."Lower Code" := '';
                  InputAmount := PreTaxCalc * LookHeaderRec."Input Factor"  ;//ProllFactorRec.Amount * LookHeaderRec."Input Factor";
                  LookLinesRec."Lower Amount" := PreTaxCalc;     //Pre calculate Tax YTD Values
                  LookLinesRec.SETRANGE("Lower Code",'');
                END
              ELSE
                EXIT (LookHeaderRec."Min. Extract Amount")
            END;
          ELSE  {Lookup table is searched with variables of type code}
            BEGIN
              LookLinesRec."Lower Amount" := 0;
              LookLinesRec."Lower Code" := EDFileRec."E/D Code";
              LookLinesRec.SETRANGE("Upper Amount",0);
              LookLinesRec.SETRANGE("Lower Amount",0);
            END

          END; { Case}

          CASE LookHeaderRec.Type OF
          0,1: BEGIN
             { Extract amount as follows; First find line where Lower Amount or
               lower code is just greater than the Factor Amount then move one
               line back.}

            IF  LookLinesRec.FIND( '=') THEN
              ReturnAmount := LookLinesRec."Extract Amount"
            ELSE
            IF  LookLinesRec.FIND( '>') THEN BEGIN
              BackOneRec :=  LookLinesRec.NEXT( -1);
              ReturnAmount := LookLinesRec."Extract Amount";
            END
            ELSE
              IF LookHeaderRec.Type = 0 THEN BEGIN
              {'Factor' Amount is > than the table's greatest "Lower amount"}
                IF  LookLinesRec.FIND( '+') THEN
                  ReturnAmount := LookLinesRec."Extract Amount";
              END
              ELSE
                EXIT (EntryLineRec.Amount);
            END;

          2: {  Extract amount from tax table}
            BEGIN
      //****Cummulative Tax Calculation****//
              ReturnAmount := (CalcTaxAmt (LookLinesRec, PreTaxCalc)) * LookHeaderRec."Output Factor";
              ReturnAmount := ReturnAmount - TaxYTD;

      //        ReturnAmount := (CalcTaxAmt (LookLinesRec, InputAmount)) *  // Changed to 2 lines
      //                                     LookHeaderRec."Output Factor"; // above
      //MESSAGE('TaxYTD: ' + FORMAT(TaxYTD) + '  ReturnAmount: ' +FORMAT(ReturnAmount));

            END;
          END; { Case }

      //MESSAGE('TaxYTD: ' + FORMAT(TaxYTD) + '  ReturnAmount_before : ' +FORMAT(ReturnAmount));

          { Adjust the amount as per the maximum/minimum in the LookupHeader}
          IF (LookHeaderRec."Max. Extract Amount" <> 0) AND
             (ReturnAmount > LookHeaderRec."Max. Extract Amount") THEN
            ReturnAmount := LookHeaderRec."Max. Extract Amount"
          ELSE
            IF (ReturnAmount < LookHeaderRec."Min. Extract Amount") THEN
              ReturnAmount := LookHeaderRec."Min. Extract Amount";

          { Check for rounding }
          IF LookHeaderRec."Rounding Precision" = 0 THEN
            RoundPrec := 0.01
          ELSE
            RoundPrec := LookHeaderRec."Rounding Precision";
          CASE LookHeaderRec."Rounding Direction" OF
            1: RoundDir := '>';
            2: RoundDir := '<';
            ELSE RoundDir := '=';
          END;
          ReturnAmount := ROUND (ReturnAmount, RoundPrec, RoundDir);

           LookLinesRec.RESET
        END;

      {Check for rounding, Maximum and minimum }

      ReturnAmount := ChkRoundMaxMin (EDFileRec, ReturnAmount);

      //MESSAGE('TaxYTD: ' + FORMAT(TaxYTD) + '  ReturnAmount_After : ' +FORMAT(ReturnAmount));

      EXIT (ReturnAmount);
      }
          CASE LookHeaderRec.Type OF
          0,2:
            BEGIN
              { Lookup table is searched with numeric variables }
              IF ProllFactorRec.Amount > -1 THEN BEGIN
                LookLinesRec."Lower Code" := '';
                InputAmount := ProllFactorRec.Amount * LookHeaderRec."Input Factor";
                LookLinesRec."Lower Amount" := InputAmount;
                 LookLinesRec.SETRANGE("Lower Code",'');
              END
              ELSE
                EXIT (LookHeaderRec."Min. Extract Amount")
            END;
          ELSE  {Lookup table is searched with variables of type code}
            BEGIN
              LookLinesRec."Lower Amount" := 0;
              LookLinesRec."Lower Code" := EDFileRec."E/D Code";
               LookLinesRec.SETRANGE("Upper Amount",0);
               LookLinesRec.SETRANGE("Lower Amount",0);
            END
          END; { Case}

          CASE LookHeaderRec.Type OF
          0,1: BEGIN
             { Extract amount as follows; First find line where Lower Amount or
               lower code is just greater than the Factor Amount then move one
               line back.}

            IF  LookLinesRec.FIND( '=') THEN
              ReturnAmount := LookLinesRec."Extract Amount"
            ELSE
            IF  LookLinesRec.FIND( '>') THEN BEGIN
              BackOneRec :=  LookLinesRec.NEXT( -1);
              ReturnAmount := LookLinesRec."Extract Amount";
            END
            ELSE
              IF LookHeaderRec.Type = 0 THEN BEGIN
              {'Factor' Amount is > than the table's greatest "Lower amount"}
                IF  LookLinesRec.FIND( '+') THEN
                  ReturnAmount := LookLinesRec."Extract Amount";
              END
              ELSE
                EXIT (EntryLineRec.Amount);
            END;

          2: {  Extract amount from tax table}
            ReturnAmount := (CalcTaxAmt (LookLinesRec, InputAmount)) *
                            LookHeaderRec."Output Factor";
          END; { Case }

          { Adjust the amount as per the maximum/minimum in the LookupHeader}
          IF (LookHeaderRec."Max. Extract Amount" <> 0) AND
             (ReturnAmount > LookHeaderRec."Max. Extract Amount") THEN
            ReturnAmount := LookHeaderRec."Max. Extract Amount"
          ELSE
            IF (ReturnAmount < LookHeaderRec."Min. Extract Amount") THEN
              ReturnAmount := LookHeaderRec."Min. Extract Amount";

          { Check for rounding }
          IF LookHeaderRec."Rounding Precision" = 0 THEN
            RoundPrec := 0.01
          ELSE
            RoundPrec := LookHeaderRec."Rounding Precision";
          CASE LookHeaderRec."Rounding Direction" OF
            1: RoundDir := '>';
            2: RoundDir := '<';
            ELSE RoundDir := '=';
          END;
          ReturnAmount := ROUND (ReturnAmount, RoundPrec, RoundDir);

           LookLinesRec.RESET
        END;

      {Check for rounding, Maximum and minimum }
      ReturnAmount := ChkRoundMaxMin (EDFileRec, ReturnAmount);

      EXIT (ReturnAmount);
    END;

    PROCEDURE CheckClosed@2() : Boolean;
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Return the value of ProllHeader."Closed?" for this Period + Employee       �
      �����������������������������������������������������������������������������}
       ProllHeader.GET("Payroll Period","Employee No");
      EXIT (ProllHeader."Closed?");
    END;

    PROCEDURE CalcTaxAmt@3(VAR LDetailsRec@1000000000 : Record 50003;TaxTableInput@1000000001 : Decimal) : Decimal;
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Returns the tax figure from a table lookup of type Tax                     �
      �����������������������������������������������������������������������������}
      { Parameters:
        by Referrence : The current Lookup detail table record = LDetailsRec.
                        NB: By referrence so that all delimitations, sortings etc
                            are still in effect.
        by value      : The amount to be taxed = TaxTableInput
      }

      //MESSAGE('Tax Table Input:' + FORMAT(TaxTableInput));

      { Copy all current filters of LookUpRec }
      PrevLookRec := LDetailsRec;
      { COPYFILTERS(LDetailsRec );          }
      {BDC
      PrevLookRec.COPYFILTERS(LDetailsRec);
      }

      IF  PrevLookRec.NEXT(-1) = 0 THEN
        ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100
      //ELSE  ReturnAmount := CalcGraduated (LDetailsRec, TaxTableInput);
      ELSE ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100;

      IF  LDetailsRec.FIND( '=') THEN
        {Record found where Lower Amount is equal to TaxTableInput}
        IF  PrevLookRec.NEXT(-1) = 0 THEN
          ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100
        ELSE
          { Call function to get the tax amount from the graduated tax table.}
        //  ReturnAmount := CalcGraduated (LDetailsRec, TaxTableInput)
           ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100
      ELSE
      IF  LDetailsRec.FIND( '>') THEN
        {Record found where Lower Amount is just larger than TaxTableInput.
         Therefore TaxableInput should be in previus range (= record)}
        IF  LDetailsRec.NEXT(-1) = 0 THEN
          { The lowest taxable amount is larger than the input amount }
          ReturnAmount := 0
        ELSE
         // ReturnAmount := CalcGraduated (LDetailsRec, TaxTableInput)
           ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100
      ELSE
        {TaxableInput is larger than the table's greatest lower amount}
        IF  LDetailsRec.NEXT(-1) = 0 THEN
          //ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100
           ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100
        ELSE
          { Call function to get the tax amount from the graduated tax table.}
        //  ReturnAmount := CalcGraduated (LDetailsRec, TaxTableInput);
           ReturnAmount := (TaxTableInput * LDetailsRec."Tax Rate %")/100;

      //MESSAGE('Tax Table Output:' + FORMAT(ReturnAmount));
      EXIT (ReturnAmount);
    END;

    PROCEDURE CalcGraduated@4(VAR WantedLookRec@1000000000 : Record 50003;InputToTable@1000000001 : Decimal) : Decimal;
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Returns the tax amount from the graduated tax table.                      �
      � Parameters                                                                �
      � by reference : The Table Lookup record within which the Taxable amount    �
      �                falls = WantedLookRec                                      �
      �                NB: By referrence so that all delimitations, sortings etc  �
      �                    are still in effect.                                   �
      � by value     : The amount to be taxed = InputToTable                      �
      ����������������������������������������������������������������������������}

      { Create a copy of the valid Look Up table Record }
      PrevLookRec :=  WantedLookRec;
       {BDC
       COPYFILTERS(WantedLookRec );
      }

      //message('Input to Graduated table: ' + FORMAT(InputToTable));
      //MESSAGE('Rate Percent to Graduated table: ' + FORMAT(WantedLookRec."Tax Rate %"));
      //message(format(PrevLookRec.count));

      IF  PrevLookRec.NEXT(-1) = 0 THEN
       ReturnAmount := (InputToTable * WantedLookRec."Tax Rate %")/100
      ELSE
      BEGIN
        { Compute tax for the amount of money that is within the range of the
          Wanted Look Up Record then add the Cumulative Tax Payable amount from
          the previous Look Up record}
         ReturnAmount :=  (InputToTable - PrevLookRec."Upper Amount");
         ReturnAmount :=  (ReturnAmount * WantedLookRec."Tax Rate %")/100;
         ReturnAmount :=  ReturnAmount + PrevLookRec."Cum. Tax Payable";
      END;
      //MESSAGE('Output from Graduated Final: ' + FORMAT(ReturnAmount));
      EXIT (ReturnAmount);
    END;

    PROCEDURE CalcCompute@5(EntryRecParam@1000000000 : Record 50006;AmountInLine@1000000001 : Decimal;"CalledFromEdCode?"@1000000002 : Boolean;EDCode@1000000003 : Code[20]);
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Depending on the value of the Compute field for the E/D File record that  �
      � corresponds to the current P.Roll Entry Line record                       �
      � Parameters :                                                              �
      �   EntryRecParam           : Current entry line                            �
      �   Amount in current line  : The figure in the amount field in this line   �
      �   "CalledFromEdCode?"     : True if the trigger code was called from the  �
      �                            "E/D Code" field                               �
      ����������������������������������������������������������������������������}

       ConstEDFileRec.GET( EntryRecParam."E/D Code");
      "E/DFileRec" := ConstEDFileRec;
      IF "E/DFileRec".Compute = '' THEN
        EXIT;

       ProllEntryRec.INIT;
       ProllEntryRec.SETRANGE("Payroll Period", EntryRecParam."Payroll Period");
       ProllEntryRec.SETRANGE("Employee No", EntryRecParam."Employee No");

      { If the entry line to be computed does not exist then EXIT }
      ProllEntryRec := EntryRecParam;
      ProllEntryRec."E/D Code" := ConstEDFileRec.Compute;
      IF NOT  ProllEntryRec.FIND( '=') THEN
        EXIT;

      { Initialise the variable to store the computed total. Note if the trigger
        code was called from the "E/D Code" field then that record is a new one.
        This implies that a search of the records in the file will not find this
        new record. Therefore for it's amount to be used in the computation
        we initialise the computed total to that amount}
      IF "CalledFromEdCode?" THEN
      BEGIN
        IF "E/DFileRec"."Add/Subtract" = 2 THEN
          { Subtract }
          ComputedTotal := - AmountInLine
        ELSE
          { Add }
          ComputedTotal := AmountInLine
      END
      ELSE
       ComputedTotal := 0;

      {Get first record in P.Roll Entry file for this Period/Employee combination}
      ProllEntryRec := EntryRecParam;
      ProllEntryRec."E/D Code" := '';
       ProllEntryRec.FIND( '>');

      { Go through all the entry lines for this Period/Employee record and sum up
        all those that contribute to the E/D specified in the Compute field for
        the current entry line }
      REPEAT
      BEGIN
        {BDC
          IF  ProllEntryRec.MARK THEN
          }
           IF  EDCode = ProllEntryRec."E/D Code" THEN
          { We are at the record where the function was called from }
          AmountToAdd := AmountInLine
        ELSE
          AmountToAdd := ProllEntryRec.Amount;

         "E/DFileRec".GET( ProllEntryRec."E/D Code");
        IF "E/DFileRec".Compute = ConstEDFileRec.Compute THEN
          IF "E/DFileRec"."Add/Subtract" = 2 THEN
            { Subtract }
            ComputedTotal := ComputedTotal - AmountToAdd
          ELSE
            { Add }
            ComputedTotal := ComputedTotal + AmountToAdd;
      END
      UNTIL ( ProllEntryRec.NEXT(1) = 0);

      { Move the computed amount to the line whose E/D Code is the one that has
        just been calculated.}
       ProllEntryRec.INIT;
      ProllEntryRec."E/D Code" := ConstEDFileRec.Compute;
       "E/DFileRec".GET( ConstEDFileRec.Compute);
      {FTN No Need
      dbTRANSFERFIELDS ("E/DFileRec", ProllEntryRec);
      }

      {Check for rounding, Maximum and minimum }
      ComputedTotal := ChkRoundMaxMin ("E/DFileRec", ComputedTotal);

      {ProllEntryRec.Amount := ComputedTotal;
      ProllRecStore := ProllEntryRec;}
       ProllEntryRec.LOCKTABLE();
      IF  ProllEntryRec.FIND( '=') THEN
      BEGIN
        {ProllRecStore.ChangeOthers := TRUE;
        ProllRecStore.HasBeenChanged := TRUE;
        dbMODIFYREC (ProllRecStore);}
        ProllEntryRec.Amount := ComputedTotal;
        ProllEntryRec.ChangeOthers := TRUE;
        ProllEntryRec.HasBeenChanged := TRUE;
         ProllEntryRec.MODIFY;
      END;
      COMMIT;

       ProllEntryRec.SETRANGE("Payroll Period");
       ProllEntryRec.SETRANGE("Employee No");
    END;

    PROCEDURE CalcFactor1@7(CurrentEntryLine@1000000000 : Record 50006);
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � If an entry is a contributory factor for the value of another line, then   �
      � compute that other line's value and insert it appropriately                �
      � Parameters :                                                               �
      �   CurrentEntryLine        : Current entry line                             �
      �����������������������������������������������������������������������������}

      { Get first record in Entry Lines file for this Employee/Period }
      ProllEntryRec := CurrentEntryLine;
       ProllEntryRec.INIT;
       ProllEntryRec.SETRANGE("Employee No", ProllEntryRec."Employee No");
       ProllEntryRec.SETRANGE("Payroll Period", ProllEntryRec."Payroll Period");
      ProllEntryRec."E/D Code" := '';
       ProllEntryRec.FIND( '>');

      { Go through all the entry lines for this Period/Employee record and where
        the current entry line's value is a factor, calculate that amount. }
      REPEAT

         "E/DFileRec".GET( ProllEntryRec."E/D Code");

        IF "E/DFileRec"."Factor Of" = CurrentEntryLine."E/D Code" THEN
        BEGIN

          FactorRecAmount := ProllEntryRec.Amount;
          ProllEntryRec.Amount := "CalcFactor1.1" (CurrentEntryLine,
                                                     ProllEntryRec,"E/DFileRec");
          {The new entry in this line should now be used to Compute another and
          also entries where it is a Factor, therefore set ChangeOthers to True}
          IF FactorRecAmount <> ProllEntryRec.Amount THEN
          BEGIN
            ProllEntryRec.ChangeOthers := TRUE;
             ProllEntryRec.MODIFY;
          END
        END;

      UNTIL ( ProllEntryRec.NEXT(1) = 0);
      COMMIT;
    END;

    PROCEDURE "CalcFactor1.1"@9(CurrLineRec@1000000000 : Record 50006;LineToChangeRec@1000000001 : Record 50006;EDFileRec@1000000002 : Record 50001) : Decimal;
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Calculate the amount based on Factor Of and Percentage fields of the file  �
      � E/D file,
      �  Parameters:                                                               �
      �    CurrLineRec    : The current entry line record                          �
      �    LineToChangeRec: The entry line to be changed.
      �    EDFileRec      : EDFile Record for the E/D Code of LineToChangeRec      �
      �����������������������������������������������������������������������������}

      { If NO is in the flag field return amount to 0 }
      IF (EDFileRec."Yes/No Req.?") AND NOT (LineToChangeRec.Flag) THEN
        EXIT (0);

      { Calculate the amount based on values in Table Look Up or Percentage fields
        of E/D file }
      IF EDFileRec."Table Look Up" = '' THEN
        ReturnAmount := (CurrLineRec.Amount * EDFileRec.Percentage) / 100
      ELSE { Extract relevant amount from Table Look Up }

        IF NOT  LookHeaderRec.GET( EDFileRec."Table Look Up") THEN
        BEGIN
          MESSAGE ('Table Lookup Not Registered Yet');
          EXIT (LineToChangeRec.Amount)
        END
        ELSE BEGIN { Table lookup exists}

          { Filter Lookupline records to those of current Table Id Only}
          LookLinesRec.TableId := EDFileRec."Table Look Up";
           LookLinesRec.SETRANGE(TableId, EDFileRec."Table Look Up");

          { Depending on whether input parameter is code or numeric, set dbSETRANGE
            appropraitely and initialise the record to use as a parameter to
            dbFINDREC }
          CASE LookHeaderRec.Type OF
          0,2:
            BEGIN
              { Lookup table is searched with numeric variables }
              IF CurrLineRec.Amount > -1 THEN BEGIN
                LookLinesRec."Lower Code" := '';
                LookLinesRec."Lower Amount" := CurrLineRec.Amount *
                                               LookHeaderRec."Input Factor";
                 LookLinesRec.SETRANGE("Lower Code",'');
              END
              ELSE
                EXIT (LookHeaderRec."Min. Extract Amount")
            END;
          ELSE  {Lookup table is searched with variables of type code}
            BEGIN
              LookLinesRec."Lower Amount" := 0;
              LookLinesRec."Lower Code" := CurrLineRec."E/D Code";
               LookLinesRec.SETRANGE("Upper Amount",0);
               LookLinesRec.SETRANGE("Lower Amount",0);
            END
          END; { Case}

          CASE LookHeaderRec.Type OF
          0,1: BEGIN
             { Extract amount as follows; First find line where Lower Amount or
               Lower Code is just greater than the CurrLineRec then move one line
               back.}

            IF  LookLinesRec.FIND( '=') THEN
              ReturnAmount := LookLinesRec."Extract Amount"
            ELSE
            IF  LookLinesRec.FIND( '>') THEN
            BEGIN
              BackOneRec :=  LookLinesRec.NEXT( -1);
              ReturnAmount := LookLinesRec."Extract Amount";
            END
            ELSE
              IF LookHeaderRec.Type = 0 THEN BEGIN
                {CurrLineRec.Amount is > than the table's greatest "Lower amount"}
                IF  LookLinesRec.FIND( '+') THEN
                  ReturnAmount := LookLinesRec."Extract Amount"
                ELSE
                  EXIT (LineToChangeRec.Amount)
              END
              ELSE
                {CurrLineRec.EDCode is > than the table's greatest "Lower code"}
                EXIT (LineToChangeRec.Amount);
            END;

          2: {  Extract amount from tax table}
                ReturnAmount := (CalcTaxAmt (LookLinesRec, PreTaxCalc *
                                             LookHeaderRec."Input Factor")) *
                                             LookHeaderRec."Output Factor";

             END; { Case }

          { Adjust the amount as per the maximum/minimum in the LookupHeader}
          IF (LookHeaderRec."Max. Extract Amount" <> 0) AND
             (ReturnAmount > LookHeaderRec."Max. Extract Amount") THEN
            ReturnAmount := LookHeaderRec."Max. Extract Amount"
          ELSE
            IF (ReturnAmount < LookHeaderRec."Min. Extract Amount") THEN
              ReturnAmount := LookHeaderRec."Min. Extract Amount";

          { Check for rounding }
          IF LookHeaderRec."Rounding Precision" = 0 THEN
            RoundPrec := 0.01
          ELSE
            RoundPrec := LookHeaderRec."Rounding Precision";
          CASE LookHeaderRec."Rounding Direction" OF
            1: RoundDir := '>';
            2: RoundDir := '<';
            ELSE RoundDir := '=';
          END;
          ReturnAmount := ROUND (ReturnAmount, RoundPrec, RoundDir);

           LookLinesRec.RESET
        END;


      { Adjust amount as per maximum/minimum set in the E/D file. This will overide
        any max/min. values set in the Table Lookup Header file}
      ReturnAmount := ChkRoundMaxMin (EDFileRec, ReturnAmount);

      EXIT (ReturnAmount);
    END;

    PROCEDURE ChangeAllOver@10(CurrentRec@1000000000 : Record 50006;CurrWasDeleted@1000000001 : Boolean);
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Go through all the lines and where a line is supposed to Change others    �
      � then change those others.                                                 �
      � Parameters :                                                              �
      �   CurrentRec      : Current Entry line                                    �
      �   CurrWasDeleted  : True if the current record was deleted                �
      ����������������������������������������������������������������������������}

      ChangeOthersRec := CurrentRec;
       ChangeOthersRec.SETRANGE("Payroll Period", CurrentRec."Payroll Period");
       ChangeOthersRec.SETRANGE("Employee No", CurrentRec."Employee No");
       ChangeOthersRec.SETRANGE(ChangeOthers, TRUE);

      ChangeOthersRec."E/D Code" := '';
      IF NOT  ChangeOthersRec.FIND( '>') THEN
        EXIT;

      {Set the maximum number of times the Amount can be changed for any one line.
       This will be used to ensure that this function does not execute 'forever',
       when the user has defined 'cyclic' E/Ds}
      MaxChangeCount := 50;

      REPEAT

        { Process the record to change others only if it isn't the deleted one }
        IF NOT (CurrWasDeleted AND (ChangeOthersRec."E/D Code" =
                                    CurrentRec."E/D Code"))
        THEN BEGIN
          ComputeAgain (ChangeOthersRec, CurrentRec, CurrWasDeleted);
          CalcFactorAgain (ChangeOthersRec, CurrentRec, CurrWasDeleted);
        END;
        ChangeOthersRec.ChangeOthers := FALSE;
        ChangeOthersRec.ChangeCounter := ChangeOthersRec.ChangeCounter + 1;
         ChangeOthersRec.MODIFY;
        ProllRecStore := ChangeOthersRec;
        ChangeOthersRec."E/D Code" := '';
      UNTIL ((ProllRecStore.ChangeCounter > MaxChangeCount) OR
             ( ChangeOthersRec.NEXT(1) = 0));
      COMMIT;
       ChangeOthersRec.SETRANGE("Payroll Period");
       ChangeOthersRec.SETRANGE("Employee No");
       ChangeOthersRec.SETRANGE(ChangeOthers);

      IF (ProllRecStore.ChangeCounter > MaxChangeCount) THEN
        MESSAGE ('The E/D Code %1, / seems to have been defined with CYCLIC' +
                 ' characteristics', ProllRecStore."E/D Code");

      EXIT;
    END;

    PROCEDURE ComputeAgain@11(ParamLine@1000000000 : Record 50006;CurrentRec@1000000001 : Record 50006;CurrWasDeleted@1000000002 : Boolean);
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Compute values for the E/D specified in the Compute field for the         �
      �  Entry Line record passed as a parameter                                  �
      � Parameters :                                                              �
      �   ParamLine       : Entry line passed as a parameter                      �
      �   CurrentRec      : Current Entry line                                    �
      �   CurrWasDeleted  : True if the current record was deleted                �
      ����������������������������������������������������������������������������}

       ConstEDFileRec.GET( ParamLine."E/D Code");
      "E/DFileRec" := ConstEDFileRec;
      IF "E/DFileRec".Compute = '' THEN
        EXIT;

       ProllEntryRec.RESET;
       ProllEntryRec.INIT;
       ProllEntryRec.SETRANGE("Payroll Period", CurrentRec."Payroll Period");
       ProllEntryRec.SETRANGE("Employee No", CurrentRec."Employee No");

      { If the entry line to be computed does not exist then EXIT }
      ProllEntryRec := ParamLine;
      ProllEntryRec."E/D Code" := ConstEDFileRec.Compute;
      IF NOT  ProllEntryRec.FIND( '=') THEN
        EXIT;

      { If CurrentRec is to be deleted, then no need to re-compute it }
      IF (CurrWasDeleted AND (ProllEntryRec."E/D Code" = CurrentRec."E/D Code"))
      THEN EXIT;

      {
        Initialise the variable to store the computed total. If a record was
        deleted then initialise to 0. Otherwise if the current line (i.e that
        entered by the user) also contributes to the computed line then we
        initialise the computed total to that amount
      }
       "E/DFileRec".GET( CurrentRec."E/D Code");
      IF CurrWasDeleted THEN
        ComputedTotal := 0
      ELSE
       IF "E/DFileRec".Compute = ConstEDFileRec.Compute THEN BEGIN
         IF "E/DFileRec"."Add/Subtract" = 2 THEN
          { Subtract }
          ComputedTotal := -  CurrentRec.Amount
         ELSE
          { Add }
          ComputedTotal := CurrentRec.Amount;
       END
       ELSE
        ComputedTotal := 0;

      {Get first record in P.Roll Entry file for this Employee group}
      ProllEntryRec := ParamLine;
      ProllEntryRec."E/D Code" := '';
       ProllEntryRec.FIND( '>');

      { Go through all the entry lines for this Employee group and sum up
        all those that contribute to the E/D specified in the Compute field for
        the current entry line }
      REPEAT

        IF ProllEntryRec."E/D Code" <> CurrentRec."E/D Code" THEN BEGIN

           "E/DFileRec".GET( ProllEntryRec."E/D Code");
          IF "E/DFileRec".Compute = ConstEDFileRec.Compute THEN
            IF "E/DFileRec"."Add/Subtract" = 2 THEN
              { Subtract }
              ComputedTotal := ComputedTotal - ProllEntryRec.Amount
            ELSE
              { Add }
              ComputedTotal := ComputedTotal + ProllEntryRec.Amount

        END
      UNTIL ( ProllEntryRec.NEXT(1) = 0);

      { Move the computed amount to the line whose E/D Code is the one that has
        just been calculated.}
       ProllEntryRec.INIT;
      ProllEntryRec."E/D Code" := ConstEDFileRec.Compute;
       "E/DFileRec".GET( ConstEDFileRec.Compute);
      {dbTRANSFERFIELDS ("E/DFileRec", ProllEntryRec);}

      {Check for rounding, Maximum and minimum }
      ComputedTotal := ChkRoundMaxMin ("E/DFileRec", ComputedTotal);

      {ProllEntryRec.Amount := ComputedTotal;
      ProllRecStore := ProllEntryRec;}

       ProllEntryRec.LOCKTABLE();
      IF  ProllEntryRec.FIND( '=') THEN
      BEGIN
        {FactorRecAmount := ProllEntryRec.Amount;}
        {ProllEntryRec := ProllRecStore;}

        {The new entry in this line should now be used to Compute another and
         also entries where it is a Factor, therefore set ChangeOthers to True}
        IF ProllEntryRec.Amount <> ComputedTotal THEN
        BEGIN
          ProllEntryRec.Amount := ComputedTotal;
          ProllEntryRec.ChangeOthers := TRUE;
           ProllEntryRec.MODIFY
        END
      END;
      COMMIT;

       ProllEntryRec.RESET;
    END;

    PROCEDURE CalcFactorAgain@12(ParamLine@1000000000 : Record 50006;CurrentRec@1000000001 : Record 50006;CurrWasDeleted@1000000002 : Boolean);
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � If a change in a line due to the entry or change to another entry is a     �
      � contributory factor for the value of another line, then  compute that      �
      �other line's value and insert it appropriately                              �
      � Parameters :                                                               �
      �   ParamLine         : Line whose value should change others                �
      �   CurrentRec        : Current Entry line                                   �
      �   CurrWasDeleted    : True if CurrentRec is to be deleted                  �
      �����������������������������������������������������������������������������}

      {Get first record in Employee Group Lines file for this Employee group}
       ProllEntryRec.RESET;
       ProllEntryRec.INIT;
       ProllEntryRec.SETRANGE("Payroll Period", ParamLine."Payroll Period");
       ProllEntryRec.SETRANGE("Employee No", ParamLine."Employee No");
      ProllEntryRec := ParamLine;
      ProllEntryRec."E/D Code" := '';
      IF NOT  ProllEntryRec.FIND( '>') THEN
        EXIT;

      { Go through all the entry lines for this Employee Group record and where
        the current entry line's value is a factor, calculate that amount. }
      REPEAT

         "E/DFileRec".GET( ProllEntryRec."E/D Code");

        IF "E/DFileRec"."Factor Of" = ParamLine."E/D Code" THEN
        BEGIN

          FactorRecAmount := ProllEntryRec.Amount;
          IF (CurrWasDeleted AND (ParamLine."E/D Code" = CurrentRec."E/D Code"))
          THEN
            ProllEntryRec.Amount := 0
          ELSE
            ProllEntryRec.Amount := "CalcFactor1.1" (ParamLine, ProllEntryRec,
                                                     "E/DFileRec");

          {The new entry in this line should now be used to Compute another and
           also entries where it is a Factor, therefore set ChangeOthers to True}
          IF FactorRecAmount <> ProllEntryRec.Amount THEN
          BEGIN
            ProllEntryRec.ChangeOthers := TRUE;
             ProllEntryRec.MODIFY
          END
        END;

      UNTIL ( ProllEntryRec.NEXT(1) = 0);
      COMMIT;

       ProllEntryRec.RESET;
    END;

    PROCEDURE ResetChangeFlags@13(CurrentRec@1000000000 : Record 50006);
    BEGIN
      {���������������������������������������������������������������������������Ŀ
      � Reset ChangeOthers to false for all lines in this Period/Employee          �
      � Parameters :                                                               �
      �   CurrentRec  : Current entry line                                         �
      �����������������������������������������������������������������������������}
      {Get first record in Employee Group Lines file for this Employee group}
      ProllEntryRec := CurrentRec;
       ProllEntryRec.INIT;
       ProllEntryRec.SETRANGE("Payroll Period", CurrentRec."Payroll Period");
       ProllEntryRec.SETRANGE("Employee No", CurrentRec."Employee No");
      ProllEntryRec."E/D Code" := '';
       ProllEntryRec.FIND( '>');

      { Reset ChangeOthers for this Employee Group }
      REPEAT

        ProllEntryRec.ChangeOthers   := FALSE;
        ChangeOthersRec.ChangeCounter := 0;
      {BDC - Do not modify the one to be deleted}
        IF ProllEntryRec."E/D Code" <> CurrentRec."E/D Code" THEN
         ProllEntryRec.MODIFY;

      UNTIL ( ProllEntryRec.NEXT(1) = 0);
      COMMIT;

       ProllEntryRec.RESET;
    END;

    PROCEDURE AmountIsComputed@8(VAR ReturnAmount@1000000000 : Decimal;EntryLineRec@1000000001 : Record 50006;EDFileRec@1000000002 : Record 50001;NewAmount@1000000003 : Decimal;EDCode@1000000004 : Code[20]) : Boolean;
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Check for values that should COMPUTE the amount for the P.Roll Entry      �
      � Line record.                                                              �
      � Return:                                                                   �
      �   If there are entries for the employee/period that compute the value     �
      �   then return TRUE else return FALSE                                      �
      � Parameters :                                                              �
      �   ReturnAmount:  The computed amount, by refference                       �
      �   EntryLineRec:  The P.Roll Entry record whose value is to be computed    �
      �   EDFileRec   :  The E/D file record of the E/D of the P.Roll Entry Record�
      �   NewAmount   :  The new calculated or entered amount in the current rec. �
      ����������������������������������������������������������������������������}

      ProllRecStore := EntryLineRec;

      {Get first record in P.Roll Entry file for this Period/Employee combination}
       ProllRecStore.SETRANGE("Payroll Period", EntryLineRec."Payroll Period");
       ProllRecStore.SETRANGE("Employee No", EntryLineRec."Employee No");
      ProllRecStore."E/D Code" := '';
      IF NOT  ProllRecStore.FIND( '>') THEN
        EXIT (FALSE);

      { Initialise the variable to store the computed total. }
      ReturnAmount := 0;
      IsComputed := FALSE;

      { Go through all the entry lines for this Period/Employee record and sum up
        all those that contribute to the E/D of the given payroll entry line }
      REPEAT
         "E/DFileRec".GET( ProllRecStore."E/D Code");
        IF "E/DFileRec".Compute = EntryLineRec."E/D Code" THEN BEGIN
      {BDC
          IF  ProllRecStore.MARK THEN
        }
          IF  ProllRecStore."E/D Code" = EDCode THEN
            AmtToAdd := NewAmount
          ELSE
            AmtToAdd := ProllRecStore.Amount;

          IF "E/DFileRec"."Add/Subtract" = 2 THEN
            { Subtract }
            ReturnAmount := ReturnAmount - AmtToAdd
          ELSE
            { Add }
            ReturnAmount := ReturnAmount + AmtToAdd;

          IsComputed := TRUE
        END
      UNTIL ( ProllRecStore.NEXT(1) = 0);

      EXIT (IsComputed);
    END;

    PROCEDURE ChangeDueToDelete@6(DeletedRec@1000000000 : Record 50006);
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Due to the deleted record, ensure all the other lines are correct.        �
      � Parameters :                                                              �
      �   DeletedRec : The current record (= the record to be deleted)            �
      �                                                                           �
      ����������������������������������������������������������������������������}
      {Get first record in Employee Group Lines file for this Employee group}
      ProllEntryRec := DeletedRec;
       ProllEntryRec.SETRANGE("Payroll Period", DeletedRec."Payroll Period");
       ProllEntryRec.SETRANGE("Employee No", DeletedRec."Employee No");

      { If the deleted record was 'COMPUTING' another then make changes }
       "E/DFileRec".GET( DeletedRec."E/D Code");
      ProllEntryRec."E/D Code" := "E/DFileRec".Compute;
      IF  ProllEntryRec.FIND( '=') THEN
        ComputeAgain (DeletedRec, DeletedRec, TRUE);

      { If another record is a 'FACTOR OF' the deleted one then make changes }
      CalcFactorAgain (DeletedRec, DeletedRec, TRUE);

      { Due to these changes adjust AMOUNTS in all lines }
      ChangeAllOver (DeletedRec, TRUE);
      EXIT;
    END;

    PROCEDURE ChkRoundMaxMin@14(EDRecord@1000000000 : Record 50001;TheAmount@1000000001 : Decimal) : Decimal;
    BEGIN
      {��������������������������������������������������������������������������Ŀ
      � Round an amount and check for Max and Min. Return the amended amount.     �
      � Parameters :                                                              �
      �   EDRecord : The ED file record to use to check Round, Max. and Min       �
      �   TheAmount: The amounht to Round, and check for Max. and Min             �
      ����������������������������������������������������������������������������}

      { Adjust amount as per maximum/minimum set in the E/D file. }
      IF (EDRecord."Max. Amount" <> 0) AND
         (TheAmount > EDRecord."Max. Amount") THEN
        TheAmount := EDRecord."Max. Amount"
      ELSE
        IF (TheAmount < EDRecord."Min. Amount") AND ("Payslip Group ID"<>"Payslip Group ID"::"TAX DEDUCTED") THEN
            TheAmount := EDRecord."Min. Amount";

      { Check for rounding }
      IF EDRecord."Rounding Precision" = 0 THEN
        RoundPrec := 0.01
      ELSE
        RoundPrec := EDRecord."Rounding Precision";
      CASE EDRecord."Rounding Direction" OF
        1: RoundDir := '>';
        2: RoundDir := '<';
        ELSE RoundDir := '=';
      END;

      TheAmount := ROUND (TheAmount, RoundPrec, RoundDir);

      EXIT (TheAmount);
    END;

    PROCEDURE EDAmountToDate@15(EmpNo@1000000000 : Code[10];CurPeriod@1000000001 : Code[10];EDCode@1000000002 : Code[10]) : Decimal;
    VAR
      AmountBack@1000000003 : Decimal;
    BEGIN

      IF PeriodRec.GET(CurPeriod) THEN
        PerStart := PeriodRec."Start Date";

      CurYear := DATE2DMY(PerStart,3);
      YearStart := CALCDATE('-CY',PerStart);

      PeriodRec.SETRANGE(PeriodRec."Start Date",YearStart);
      IF PeriodRec.FIND('-') THEN
        Per1 := PeriodRec."Period Code";

      EmployeeRec.GET("Employee No");
      EmployeeRec.SETRANGE(EmployeeRec."Employee No. Filter","Employee No");
      EmployeeRec.SETRANGE("Period Filter",Per1,CurPeriod);
      EmployeeRec.SETRANGE("ED Filter",EDCode);

      EmployeeRec.CALCFIELDS(EmployeeRec.EDAmount);
      AmountBack := EmployeeRec.EDAmount;

      //MESSAGE(FORMAT(Per1)+'..'+FORMAT(CurPeriod));
      //message(EDCode + ' -> ' + format(AmountBack));

      EXIT(AmountBack);
    END;

    PROCEDURE GetParam@17();
    BEGIN
      PaySetup.RESET;
      PaySetup.FIND('-');
      DaysInMonth := PaySetup."Monthly Working Days";
      HrsInDay := PaySetup."Daily Working Hours";

      IF ("Employee No" <>'') THEN BasicPay := EmployeeRec.GetBasic("Employee No");
    END;

    PROCEDURE PreTaxCalc@21() : Decimal;
    VAR
      Ret1@1000000000 : Decimal;
    BEGIN
      /////////** Begin Cummulative Tax Calculation **/////////

      EDRec2.RESET;
      EDRec2.SETRANGE(EDRec2."Payslip Group ID",EDRec2."Payslip Group ID"::"TAXABLE PAY");
      IF EDRec2.FIND('-') THEN TaxableED := EDRec2."E/D Code";
      EDRec2.RESET;
      EDRec2.SETRANGE(EDRec2."Payslip Group ID",EDRec2."Payslip Group ID"::"TAX DEDUCTED");
      IF EDRec2.FIND('-') THEN TaxED := EDRec2."E/D Code";

      PaySetup.RESET;
      PaySetup.FIND('-');
      TaxfreeED :=  PaySetup."Taxfree Pay ED";

      CurrTaxable := 0;
      IF TaxableED <> '' THEN
        IF PayLines2.GET("Payroll Period","Employee No",TaxableED) THEN
          CurrTaxable := PayLines2.Amount
        ELSE
          ERROR('Please Indicate the Taxable ED in The ED Table\\'+
                'Using the payslip Group ID Field');

      TaxableYTD := EDAmountToDate("Employee No","Payroll Period",TaxableED);   // + CurrTaxable;
      TaxYTD     := EDAmountToDate("Employee No","Payroll Period",TaxED);

      TaxFreeYTD := EDAmountToDate("Employee No","Payroll Period",TaxfreeED);
      NewEmpRec.GET("Employee No");
      AmountToTax := TaxableYTD - TaxFreeYTD;

      // + NewEmpRec."Annual Tax Freepay"/12; //Add Tafree again to Avoid double deduction

      //MESSAGE(' TaxableYTD:' + FORMAT(TaxableYTD)+' TaxFreeYTD:' + FORMAT(TaxFreeYTD)+'\\'+
      //        ' TaxYTD:' + FORMAT(TaxYTD)+' AmountToTax:' + FORMAT(AmountToTax));

      //Ret1 := (CalcTaxAmt (LookLinesRec, AmountToTax * LookHeaderRec."Input Factor")) * LookHeaderRec."Output Factor";

      //MESSAGE(' Taxable:' + FORMAT(TaxableYTD)+' TaxFreeYTD:' + FORMAT(TaxFreeYTD)+'\\'+
      //        ' TaxYTD:' + FORMAT(TaxYTD)+' AmountToTax:' + FORMAT(AmountToTax)+'\\'+
      //        ' ReturnAmount:' + FORMAT(Ret1));

      EXIT(AmountToTax);

      /////////** End  Cummulative Tax Calculation **/////////
    END;

    BEGIN
    END.
  }
}

